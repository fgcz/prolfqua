---
title: "Comparing Two Groups with prolfqua"
author: "Witold E. Wolski"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{Comparing Two Groups with prolfqua} 
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography:
  - prolfqua.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
conflicted::conflict_prefer("filter", "dplyr")
```

# Purpose

This vignette demonstrates how two conditions or groups can be compared and statistically evaluated. We will again use the Ionstar dataset processed with MaxQuant as LFQ experiment with MBR option. After some standard preprocessing, we compare the replicates with the different dilutions with each other in the end. The output of such a two-group comparison is usually a difference in the mean intensities for quantified proteins (log2 fold-change) along with some statistical parameters such as a p-value or an FDR. 

# Input data

In the following, we load protein abundances in the `proteinGroups.txt` file generated by the MaxQuant software. 

```{r loadPackageLibrary}
library(prolfqua)
```

Specify the path to the MaxQuant `proteinGroups.txt` file. The `prolfqua` function `tidyMQ_ProteinGroups` will read the `proteinGroups.txt` file and convert it into a tidy table

```{r LoadDataAndConfigure}
## TODO(WEW): in the tiny data there is NO protein that is missing in one
## condition we should have some proteins in (5-10)

datadir <- file.path(find.package("prolfqua") , "samples/maxquant_txt")
inputMQfile <- file.path(datadir, "tiny2.zip")
inputAnnotation <- file.path(datadir, "annotation_Ionstar2018_PXD003881.xlsx")

## use prolfqua 1st time
startdata <- prolfqua::tidyMQ_ProteinGroups(inputMQfile)
```

Read the sample annotation. The sample annotation must contain the `raw.file` name and the explanatory variables of our experiment, e.g., treatment, timepoint, genetic background, or other `factors` which we would like to check for confounding effects.

```{r readAnnotation}
annotation <- readxl::read_xlsx(inputAnnotation)
head(annotation)
```

Merge the annotation with quantitative data using `inner_join` joining by `raw.file`.

```{r addAnnotationToData}
startdata <- dplyr::inner_join(annotation, startdata, by = "raw.file")
```

We remove all proteins identified only by a single peptide.

```{r filterForAtLeastTwoPeptides}
startdata <- dplyr::filter(startdata, nr.peptides > 1)
```

Then we need to _tell_ `prolfqua` which columns in the data frame contain what information. We do it by using the `AnalysisTableAnnotation` class.

# Creating an `prolfqua` object

```{r setupConfigs}
atable <- prolfqua::AnalysisTableAnnotation$new()
# prints AnalysisTableAnnotation object
atable
```

Among all the fields contained in the object listed above, the `AnalysisTableAnnotation` has the following fields that always need to be populated:

- `fileName`
- `hierarchy`
- `factors`
- `workingIntensity`

The column `fileName` contains the raw file names, however for labeled TMT experiments, it can be used to hold the name of the TMT channel.

```{r specifyRawFile}
atable$fileName <- "raw.file"
```

The `hierarchy` field describes the structure of the MS data, e.g., 

- protein 
- peptides
- modified peptides
- precursor

Using the MaxQuant `proteinGroups.txt` file, we already have the data on the protein level; therefore we specify as follows:

```{r specifyProteinID}
atable$hierarchy[["protein_Id"]] <- c("proteinID")
```

In addition, we need to describe the `factors` of the analysis, i.e., the column containing the explanatory variables. By setting the `factorDepth` variable to $1$, we include only the "dilution." variable in the modeling.

```{r specifyFactors}
atable$factors[["dilution."]] = "sample"
```

We also need to specify the column containing the protein abundances.

```{r specifyIntensity}
atable$set_response("mq.protein.intensity")
```

Finally, we create the `AnalysisConfiguration`, which needs the `AnalysisTableAnnotation` we just created, and the `AnalysisParameters`. 

```{r createAnalysisConfig}
config <- AnalysisConfiguration$new(atable)
```

```{r setupAnalysis}
adata <- setup_analysis(startdata, config)
```

Create the `LFQData` class instance and remove zeros from the data. Of note, the MaxQuant software encodes missing values with zero.

```{r removeSmallIntensities}
lfqdata <- prolfqua::LFQData$new(adata, config)
lfqdata$remove_small_intensities()
```

Now the first setup of the analysis is done. The prolfqua object provides print methods, e.g., for listing the factor setup or for printing the quantitative data.

```{r printFactors}
lfqdata$factors()
```

The following lines calls the print method and displays the data in _long format_:

```{r}
lfqdata$data
```

We can always convert the data into _wide format_ by using the following code snippet:

```{r showWide, eval = TRUE}
lfqdata$to_wide()$data
```

# Visualization of not normalized data

As the next step, we show how to normalize the proteins and the effect of normalization. Furthermore, we use some functions to visualize the missing values in our data.

```{r getPlotter}
lfqplotter <- lfqdata$get_Plotter()
density_nn <- lfqplotter$intensity_distribution_density()
```

## Visualization of missing data

```{r makeMissingHeatmap, fig.cap="Heatmap where missing proteins (zero in case of MaxQuant reported intensities), black - missing protein intensities, white - present"}
lfqplotter$NA_heatmap()
```

```{r missignessPerGroup, fig.cap="# of proteins with 0,1,...N missing values"}
lfqdata$get_Summariser()$plot_missingness_per_group()
```

```{r missignessHistogram, fig.cap="Intensity distribution of proteins depending on # of missing values"}
lfqplotter$missigness_histogram()
```

## Computing standard deviations, mean and CV.

Other important statistics, such as coefficient of variation, means and standard deviations, can be calculated using the `get_Stats` function and visualized with a violin plot.

```{r PlotCVDistributions, fig.cap="Violin plots of CVs in the different groups and among all groups"}
stats <- lfqdata$get_Stats()
stats$violin()
prolfqua::table_facade( stats$stats_quantiles()$wide,
    paste0("quantile of ", stats$stat ))
```

```{r plotCVsplitbyMedianIntensity, fig.cap="Distribution of CV's for top 50% and bottom 50% proteins by intensity."}
stats$density_median()
```

## Normalize protein intensities and show diagnostic plots

We normalize the data by $\log_2$ transforming and then $z-scaling$.

```{r normalizedata}
lt <- lfqdata$get_Transformer()
transformed <- lt$log2()$robscale()$lfq
transformed$config$table$is_response_transformed

```

```{r genplotNorm, fig.cap="Normalized intensities."}
pl <- transformed$get_Plotter()
density_norm <- pl$intensity_distribution_density()
```

```{r showIntensityDistributions, fig.cap="Distribution of intensities before and after normalization."}
gridExtra::grid.arrange(density_nn, density_norm)
```

```{r plotScatterMatrix, fig.cap = "Scatterplot matrix", fig.height=8, fig.retina=3}
pl$pairs_smooth()
```

```{r createHeatmap}
p <- pl$heatmap_cor()
```

```{r plotHeatmap, fig.cap="Heatmap, Rows - proteins, Columns - samples", fig.align=5, fig.height=5}
p
```

# Fitting a linear model 

For fitting linear models to the transformed intensities for all our proteins, we have to specify the _model function_ and define the _contrasts_ we want to calculate.

Therefore the method below tells us the response name.

```{r printResponseVariableName}
transformed$config$table$get_response()
```

Now we can define the model by

```{r defineModel}
formula_Condition <- strategy_lm("transformedIntensity ~ dilution.")
```

A sanity check shows a a frequencies of the dilutions:

```{r someDilutionStatistics}
transformed$data$dilution. |> table()
```

The contrasts, we will use later, are defined as follow:

```{r defineContrasts}
Contrasts <- c("dila - dilb" = "dilution.a - dilution.b",
  "AvsC" = "dilution.a - dilution.c")
```

Here we have to build the model for each protein.

```{r buildModel}
mod <- prolfqua::build_model(
  transformed$data,
  formula_Condition,
  subject_Id = transformed$config$table$hierarchy_keys() )

```

TODO(WEW): which plot exactly and why?
In the plot, we can see what factors in our model are mostly responsible for the adjusted p-values calculated from an analysis of variance.

```{r showANOVA, fig.cap="Distribtuion of adjusted p-values (FDR)"}
mod$anova_histogram("FDR.Pr..F.")
```

One also looks at what proteins show different abundances in our five dilutions by looking at the FDR values of the analysis of variance.

```{r aovtableStatistics}
aovtable <- mod$get_anova()
aovtable |> head()
aovtable |> dim()
```

```{r filterDataForFDR}
xx <- aovtable |>
    dplyr::filter(FDR.Pr..F. < 0.2)

signif <- transformed$get_copy()
signif$data <- signif$data |>
    dplyr::filter(protein_Id %in% xx$protein_Id)

hmSig <- signif$get_Plotter()$heatmap()
```

```{r showSigHeatmap, fig.cap="Heatmap for proteins with FDR < 0.2 in the analysis of variance"}
hmSig
```

# Compute contrasts

Next we do calculate the statistics for our defined contrasts for all the proteins. For this we can use the `Contrasts` function.

We previously  defined `Contrasts` as
```{r printContrasts}
Contrasts
```

```{r computeContrasts}
contr <- prolfqua::Contrasts$new(mod, Contrasts)
v1 <- contr$get_Plotter()$volcano()
```

Alternatively, we can moderate the variance and using the Experimental Bayes method implemented in `ContrastsModerated`.

```{r computeContrastsModerated}
contr <- prolfqua::ContrastsModerated$new(contr)
contrdf <- contr$get_contrasts()
```

In the next figure it can be seen TODO(WEW): input NEEDED.

```{r plotVolcanos, fig.cap="Volcano plot, Left panel - no moderation, Right panel - with moderation."}
plotter <- contr$get_Plotter()
v2 <- plotter$volcano()
gridExtra::grid.arrange(v1$FDR,v2$FDR, ncol = 1)
```

```{r showMAplot, fig.cap="MA plot showing the dependency of mean abuncance with respect to the difference"}
plotter$ma_plotly()
```


```{r checkProteinsInOutput}
myProteinIDS <- c("sp|P0AC33|FUMA_ECOLI", 
                  "sp|P28635|METQ_ECOLI",
                  "sp|Q14C86|GAPD1_HUMAN")
dplyr::filter(contrdf, protein_Id %in% myProteinIDS)
```


# Contrasts with missing value imputation

Use this method if there are proteins with no observations in one of the groups.  With the `ContrastsSimpleImpute` function, we can estimate the difference in mean for proteins that are not observed in one group or condition. For this, we are using the average expression at percentile $0.05$ of the group where the protein is not quantified. 

```{r computeMissing, eval=TRUE}
# ToDo_WeW: in the tiny data there is NO protein that is missing in one condition
# we should have some proteins in (5-10)
mC <- ContrastsSimpleImpute$new(lfqdata = transformed, contrasts = Contrasts)
colnames(mC$get_contrasts())
```

Finally, we are merging the results and giving priority to the results where we do not have missing values in one group.

```{r mergeResults, fig.ret=3, fig.cap="Volcano plots for the two contrasts with missing value imputation from the group_average model."}
merged <- prolfqua::merge_contrasts_results(prefer = contr,add = mC)$merged
plotter <- merged$get_Plotter()
## perform the plotting
plotter$volcano()$FDR
```

Look at any proteins that could not be fitted using the linear model.

```{r mergedMore}
merged <- prolfqua::merge_contrasts_results(prefer = contr, add = mC)

moreProt <- transformed$get_copy()
moreProt$data <- moreProt$data |>
  dplyr::filter(protein_Id %in% merged$more$contrast_result$protein_Id)
moreProt$get_Plotter()$raster()
```
Of note, here we do not get anything because there is nothing imputed.

# Gene Set Enrichment Analyis

We can rank the proteins based on the log2FC or the t-statistic and subject them to gene set enrichment analysis (see GSEA).

The example in this section requires the following R packages installed:

- `r BiocStyle::Biocpkg('clusterProfiler')`
- `r BiocStyle::Biocpkg('org.Sc.sgd.db')`
- `r BiocStyle::Githubpkg('prora')`

```{r checkForGSEA, warning=TRUE}
evalAll <- require("clusterProfiler") &
  require("org.Sc.sgd.db2") &
  require("prora")
```

```{r clusterProfiler, eval=evalAll}
library(clusterProfiler)
library(org.Sc.sgd.db)

bb <- prolfqua::get_UniprotID_from_fasta_header(merged$merged$get_contrasts(),
                                             idcolumn = "protein_Id")
bb <- prora::map_ids_uniprot(bb)
ranklist <- bb$statistic
names(ranklist) <- bb$P_ENTREZGENEID
res <- clusterProfiler::gseGO(
  sort(ranklist, decreasing = TRUE),
  OrgDb = org.Sc.sgd.db,
  ont = "ALL")
```

```{r ridgeplot, fig.cap="ridgeplot", eval = evalAll}
ridgeplot(res)
```

```{r dotplot, fig.cap = "Dotplot", eval = evalAll}
dotplot(res , showCategory = 30)
```

```{r upsetplot, fig.cap="Upset Plot", eval = evalAll}
enrichplot::upsetplot(res)
```

The `prolfqua` package is described in [@Wolski2022.06.07.494524].

# Session Info

```{r}
sessionInfo()
```

# References

